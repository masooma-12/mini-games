<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze of the Phantom Chase</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            background-color: #111;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
            overflow: hidden;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
        
        .title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f, 0 0 20px #f0f;
            text-align: center;
        }
        
        .subtitle {
            font-size: 24px;
            margin-bottom: 40px;
            color: #0ff;
            text-align: center;
        }
        
        .button {
            padding: 15px 30px;
            background-color: #f0f;
            color: #000;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        
        .button:hover {
            background-color: #0ff;
            transform: scale(1.05);
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        #time-display {
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 20px;
            color: #fff;
        }
        
        #lives-display {
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 20px;
            color: #fff;
        }
        
        #level-display {
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 20px;
            color: #fff;
        }
        
        #powers-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        
        .power-item {
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            position: relative;
            cursor: pointer;
            pointer-events: all;
        }
        
        .power-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .power-item .cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: rgba(255, 0, 255, 0.5);
            border-radius: 5px;
            transition: height 0.1s linear;
        }
        
        .power-key {
            position: absolute;
            top: -15px;
            right: -5px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
            color: #fff;
        }
        
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 20px;
            border-radius: 10px;
            font-size: 24px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #minimap {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #f0f;
            border-radius: 5px;
        }
        
        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
            display: none;
            z-index: 90;
        }
        
        #tutorial h2 {
            color: #f0f;
            margin-bottom: 10px;
        }
        
        #tutorial p {
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        #tutorial .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        #tutorial .control-item {
            width: 48%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        #tutorial .key {
            display: inline-block;
            padding: 5px 10px;
            background-color: #333;
            border-radius: 5px;
            margin-right: 10px;
            font-weight: bold;
        }
        
        #settings-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            width: 400px;
            display: none;
            z-index: 90;
        }
        
        #settings-panel h2 {
            color: #f0f;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .setting-item {
            margin-bottom: 15px;
        }
        
        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .setting-item select, .setting-item input {
            width: 100%;
            padding: 8px;
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
        }
        
        .setting-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        #particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }
        
        .footstep {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            opacity: 1;
            transition: opacity 2s;
        }
        
        .fadeout {
            opacity: 0;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- UI Elements -->
        <div id="ui-container">
            <div id="time-display">Time: 3:00</div>
            <div id="level-display">Level: 1</div>
            <div id="lives-display">Lives: 3 ‚ù§Ô∏è</div>
        </div>
        
        <div id="powers-container">
            <div class="power-item" id="power-dash">
                <div class="power-key">1</div>
                üåÄ
                <div class="cooldown"></div>
            </div>
            <div class="power-item" id="power-invisible">
                <div class="power-key">2</div>
                üï∂Ô∏è
                <div class="cooldown"></div>
            </div>
            <div class="power-item" id="power-decoy">
                <div class="power-key">3</div>
                üö™
                <div class="cooldown"></div>
            </div>
            <div class="power-item" id="power-beacon">
                <div class="power-key">4</div>
                üî¶
                <div class="cooldown"></div>
            </div>
            <div class="power-item" id="power-trap">
                <div class="power-key">5</div>
                ü™§
                <div class="cooldown"></div>
            </div>
        </div>
        
        <div id="minimap"></div>
        
        <div class="notification" id="notification"></div>
        
        <div id="particles-container"></div>
        
        <div id="start-screen">
            <h1 class="title">Maze of the Phantom Chase</h1>
            <p class="subtitle">Can you escape the ever-changing labyrinth?</p>
            <button class="button" id="start-button">Start Game</button>
            <button class="button" id="tutorial-button">How to Play</button>
            <button class="button" id="settings-button">Settings</button>
        </div>
        
        <div id="game-over">
            <h1 class="title">Game Over</h1>
            <p class="subtitle" id="game-over-message">The phantom caught you!</p>
            <p class="subtitle">You reached Level <span id="final-level">1</span></p>
            <button class="button" id="retry-button">Try Again</button>
            <button class="button" id="main-menu-button">Main Menu</button>
        </div>
        
        <div id="tutorial">
            <h2>How to Play</h2>
            <p>You're trapped in a mysterious maze with a relentless phantom chasing you. Find the exit before time runs out or the phantom catches you!</p>
            
            <h3>Controls:</h3>
            <div class="controls">
                <div class="control-item">
                    <span class="key">WASD</span> Move
                </div>
                <div class="control-item">
                    <span class="key">SHIFT</span> Sprint (limited)
                </div>
                <div class="control-item">
                    <span class="key">1-5</span> Use Powers
                </div>
                <div class="control-item">
                    <span class="key">E</span> Interact
                </div>
            </div>
            
            <h3>Powers:</h3>
            <p>üåÄ <strong>Dash</strong> - Burst of speed to escape danger<br>
            üï∂Ô∏è <strong>Invisibility</strong> - Become invisible for a few seconds<br>
            üö™ <strong>Decoy</strong> - Create a fake clone to distract the phantom<br>
            üî¶ <strong>Light Beacon</strong> - Stun the phantom temporarily<br>
            ü™§ <strong>Trap</strong> - Place a trap to slow down the phantom</p>
            
            <p>The maze constantly changes - be aware of your surroundings! Collect items and power-ups to help you escape.</p>
            
            <button class="button" id="tutorial-close">Got it!</button>
        </div>
        
        <div id="settings-panel">
            <h2>Settings</h2>
            
            <div class="setting-item">
                <label for="difficulty">Difficulty</label>
                <select id="difficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                    <option value="nightmare">Nightmare</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label for="theme">Maze Theme</label>
                <select id="theme">
                    <option value="haunted" selected>Haunted Mansion</option>
                    <option value="scifi">Sci-Fi Spaceship</option>
                    <option value="catacombs">Underground Catacombs</option>
                    <option value="cyberpunk">Cyberpunk City</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label for="music-volume">Music Volume</label>
                <input type="range" id="music-volume" min="0" max="100" value="50">
            </div>
            
            <div class="setting-item">
                <label for="sfx-volume">Sound Effects Volume</label>
                <input type="range" id="sfx-volume" min="0" max="100" value="70">
            </div>
            
            <div class="setting-buttons">
                <button class="button" id="settings-save">Save</button>
                <button class="button" id="settings-cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
        // Game Constants
        const CELL_SIZE = 40;
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 25;
        const POWER_UP_SIZE = 15;
        const TRAP_SIZE = 20;
        const DECOY_SIZE = 20;
        const EXIT_SIZE = 30;
        
        // Game Variables
        let canvas, ctx;
        let gameLoop;
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameOver'
        let level = 1;
        let lives = 3;
        let timeLeft = 180; // in seconds
        let score = 0;
        let maze = [];
        let mazeWidth = 15;
        let mazeHeight = 15;
        let player = { x: 0, y: 0, speed: 3, isSprinting: false, sprintEnergy: 100, isInvisible: false };
        let enemies = [];
        let powerUps = [];
        let traps = [];
        let decoys = [];
        let exit = { x: 0, y: 0 };
        let footsteps = [];
        let lastFootstepTime = 0;
        
        // Power cooldowns (in seconds)
        let powerCooldowns = {
            dash: 0,
            invisible: 0,
            decoy: 0,
            beacon: 0,
            trap: 0
        };
        
        // Max cooldowns
        const MAX_COOLDOWNS = {
            dash: 5,
            invisible: 10,
            decoy: 15,
            beacon: 20,
            trap: 8
        };
        
        // Key states
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            sprint: false,
            interact: false
        };
        
        // Game settings
        let settings = {
            difficulty: 'medium',
            theme: 'haunted',
            musicVolume: 50,
            sfxVolume: 70
        };
        
        // Theme colors
        const themes = {
            haunted: {
                wall: '#3a0042',
                floor: '#220026',
                player: '#00ffff',
                enemy: '#ff0088',
                exit: '#00ff00',
                powerUp: '#ffff00',
                ambient: 'rgba(128, 0, 128, 0.03)',
                particleColor: 'rgba(128, 0, 255, 0.2)'
            },
            scifi: {
                wall: '#003366',
                floor: '#001133',
                player: '#00ffff',
                enemy: '#ff0000',
                exit: '#00ff99',
                powerUp: '#ffff33',
                ambient: 'rgba(0, 128, 255, 0.03)',
                particleColor: 'rgba(0, 200, 255, 0.2)'
            },
            catacombs: {
                wall: '#332211',
                floor: '#221100',
                player: '#ffaa00',
                enemy: '#660000',
                exit: '#00aa00',
                powerUp: '#ffff00',
                ambient: 'rgba(83, 53, 10, 0.03)',
                particleColor: 'rgba(255, 153, 0, 0.2)'
            },
            cyberpunk: {
                wall: '#220033',
                floor: '#110022',
                player: '#00ffaa',
                enemy: '#ff00ff',
                exit: '#ffff00',
                powerUp: '#00ffff',
                ambient: 'rgba(255, 0, 255, 0.03)',
                particleColor: 'rgba(0, 255, 255, 0.2)'
            }
        };
        
        // DOM elements
        const startScreen = document.getElementById('start-screen');
        const gameOver = document.getElementById('game-over');
        const timeDisplay = document.getElementById('time-display');
        const livesDisplay = document.getElementById('lives-display');
        const levelDisplay = document.getElementById('level-display');
        const notification = document.getElementById('notification');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalLevel = document.getElementById('final-level');
        const minimap = document.getElementById('minimap');
        const tutorial = document.getElementById('tutorial');
        const settingsPanel = document.getElementById('settings-panel');
        const particlesContainer = document.getElementById('particles-container');
        
        // Power elements
        const powerDash = document.getElementById('power-dash');
        const powerInvisible = document.getElementById('power-invisible');
        const powerDecoy = document.getElementById('power-decoy');
        const powerBeacon = document.getElementById('power-beacon');
        const powerTrap = document.getElementById('power-trap');
        
        // Button elements
        const startButton = document.getElementById('start-button');
        const tutorialButton = document.getElementById('tutorial-button');
        const settingsButton = document.getElementById('settings-button');
        const retryButton = document.getElementById('retry-button');
        const mainMenuButton = document.getElementById('main-menu-button');
        const tutorialClose = document.getElementById('tutorial-close');
        const settingsSave = document.getElementById('settings-save');
        const settingsCancel = document.getElementById('settings-cancel');
        
        // Initialize the game
        function init() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = 800;
            canvas.height = 600;
            
            // Set up event listeners
            setupEventListeners();
            
            // Initialize minimap
            setupMinimap();
            
            // Start main menu
            showStartScreen();
        }
        
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Button events
            startButton.addEventListener('click', startGame);
            tutorialButton.addEventListener('click', showTutorial);
            settingsButton.addEventListener('click', showSettings);
            retryButton.addEventListener('click', restartGame);
            mainMenuButton.addEventListener('click', showStartScreen);
            tutorialClose.addEventListener('click', hideTutorial);
            settingsSave.addEventListener('click', saveSettings);
            settingsCancel.addEventListener('click', hideSettings);
            
            // Power button events
            powerDash.addEventListener('click', () => usePower('dash'));
            powerInvisible.addEventListener('click', () => usePower('invisible'));
            powerDecoy.addEventListener('click', () => usePower('decoy'));
            powerBeacon.addEventListener('click', () => usePower('beacon'));
            powerTrap.addEventListener('click', () => usePower('trap'));
        }
        
        function handleKeyDown(e) {
            if (gameState !== 'playing') return;
            
            switch (e.key.toLowerCase()) {
                case 'w':
                    keys.up = true;
                    break;
                case 's':
                    keys.down = true;
                    break;
                case 'a':
                    keys.left = true;
                    break;
                case 'd':
                    keys.right = true;
                    break;
                case 'shift':
                    keys.sprint = true;
                    break;
                case 'e':
                    keys.interact = true;
                    break;
                case '1':
                    usePower('dash');
                    break;
                case '2':
                    usePower('invisible');
                    break;
                case '3':
                    usePower('decoy');
                    break;
                case '4':
                    usePower('beacon');
                    break;
                case '5':
                    usePower('trap');
                    break;
                case 'escape':
                    togglePause();
                    break;
            }
        }
        
        function handleKeyUp(e) {
            switch (e.key.toLowerCase()) {
                case 'w':
                    keys.up = false;
                    break;
                case 's':
                    keys.down = false;
                    break;
                case 'a':
                    keys.left = false;
                    break;
                case 'd':
                    keys.right = false;
                    break;
                case 'shift':
                    keys.sprint = false;
                    break;
                case 'e':
                    keys.interact = false;
                    break;
            }
        }
        
        function showStartScreen() {
            gameState = 'start';
            startScreen.style.display = 'flex';
            gameOver.style.display = 'none';
            
            // Clear any running game loop
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
        }
        
        function showTutorial() {
            tutorial.style.display = 'block';
        }
        
        function hideTutorial() {
            tutorial.style.display = 'none';
        }
        
        function showSettings() {
            settingsPanel.style.display = 'block';
            
            // Set current settings in form
            document.getElementById('difficulty').value = settings.difficulty;
            document.getElementById('theme').value = settings.theme;
            document.getElementById('music-volume').value = settings.musicVolume;
            document.getElementById('sfx-volume').value = settings.sfxVolume;
        }
        
        function hideSettings() {
            settingsPanel.style.display = 'none';
        }
        
        function saveSettings() {
            // Get values from form
            settings.difficulty = document.getElementById('difficulty').value;
            settings.theme = document.getElementById('theme').value;
            settings.musicVolume = document.getElementById('music-volume').value;
            settings.sfxVolume = document.getElementById('sfx-volume').value;
            
            // Hide panel
            hideSettings();
        }
        
        function setupMinimap() {
            const minimapCanvas = document.createElement('canvas');
            minimapCanvas.width = 150;
            minimapCanvas.height = 150;
            minimap.appendChild(minimapCanvas);
        }
        
        function updateMinimap() {
            const minimapCanvas = minimap.querySelector('canvas');
            const minimapCtx = minimapCanvas.getContext('2d');
            
            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Calculate cell size for minimap
            const cellWidth = minimapCanvas.width / mazeWidth;
            const cellHeight = minimapCanvas.height / mazeHeight;
            
            // Draw maze walls
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        minimapCtx.fillStyle = themes[settings.theme].wall;
                        minimapCtx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            // Draw exit
            minimapCtx.fillStyle = themes[settings.theme].exit;
            minimapCtx.fillRect(exit.x * cellWidth, exit.y * cellHeight, cellWidth, cellHeight);
            
            // Draw player
            minimapCtx.fillStyle = themes[settings.theme].player;
            const playerMinimapX = player.x / (mazeWidth * CELL_SIZE) * minimapCanvas.width;
            const playerMinimapY = player.y / (mazeHeight * CELL_SIZE) * minimapCanvas.height;
            minimapCtx.fillRect(playerMinimapX - 2, playerMinimapY - 2, 4, 4);
            
            // Draw enemies
            minimapCtx.fillStyle = themes[settings.theme].enemy;
            enemies.forEach(enemy => {
                const enemyMinimapX = enemy.x / (mazeWidth * CELL_SIZE) * minimapCanvas.width;
                const enemyMinimapY = enemy.y / (mazeHeight * CELL_SIZE) * minimapCanvas.height;
                minimapCtx.fillRect(enemyMinimapX - 2, enemyMinimapY - 2, 4, 4);
            });
        }
        
        function startGame() {
            // Reset game state
            level = 1;
            lives = 3;
            timeLeft = 180;
            score = 0;
            
            // Hide start screen
            startScreen.style.display = 'none';
            
            // Initialize game
            gameState = 'playing';
            
            // Generate maze for level 1
            generateMaze();
            
            // Start game loop
            lastFrameTime = Date.now();
            gameLoop = requestAnimationFrame(update);
            
            // Show notification
            showNotification("Level 1: Find the exit!", 3000);
        }
        
        function restartGame() {
            gameOver.style.display = 'none';
            startGame();
        }
        
        function nextLevel() {
            level++;
            
            // Increase maze size every 3 levels
            if (level % 3 === 0) {
                mazeWidth += 2;
                mazeHeight += 2;
            }
            
            // Reset time based on maze size
            timeLeft = Math.max(mazeWidth, mazeHeight) * 12;
            
            // Generate new maze
            generateMaze();
            
            // Show notification
            showNotification(`Level ${level}: Find the exit!`, 3000);
            
            // Update level display
            levelDisplay.textContent = `Level: ${level}`;
        }
        
        function generateMaze() {
            // Initialize empty maze
            maze = [];
            for (let y = 0; y < mazeHeight; y++) {
                maze[y] = [];
                for (let x = 0; x < mazeWidth; x++) {
                    maze[y][x] = 1; // 1 = wall, 0 = path
                }
            }
            
            // Generate maze using recursive backtracking
            const startX = 1;
            const startY = 1;
            generatePath(startX, startY);
            
            // Place player at start
            player.x = startX * CELL_SIZE + CELL_SIZE / 2;
            player.y = startY * CELL_SIZE + CELL_SIZE / 2;
            player.sprintEnergy = 100;
            player.isInvisible = false;
            
            // Place exit
            let exitPlaced = false;
            while (!exitPlaced) {
                const exitX = mazeWidth - 2;
                const exitY = mazeHeight - 2;
                
                if (maze[exitY][exitX] === 0) {
                    exit.x = exitX;
                    exit.y = exitY;
                    exitPlaced = true;
                }
            }
            
            // Place enemies
            enemies = [];
            const numEnemies = Math.min(Math.floor(level / 2) + 1, 5);
            
            for (let i = 0; i < numEnemies; i++) {
                let enemyPlaced = false;
                while (!enemyPlaced) {
                    const x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;
                    
                    // Check if cell is empty and far enough from player
                    const distFromPlayer = Math.sqrt(
                        Math.pow((x * CELL_SIZE + CELL_SIZE / 2) - player.x, 2) +
                        Math.pow((y * CELL_SIZE + CELL_SIZE / 2) - player.y, 2)
                    );
                    
                    if (maze[y][x] === 0 && distFromPlayer > 5 * CELL_SIZE) {
                        enemies.push({
                            x: x * CELL_SIZE + CELL_SIZE / 2,
                            y: y * CELL_SIZE + CELL_SIZE / 2,
                            speed: 1.5 + (level * 0.1), // Increase speed with level
                            direction: Math.random() * Math.PI * 2, // Random initial direction
                            isStunned: false,
                            stunnedTimer: 0
                        });
                        enemyPlaced = true;
                    }
                }
            }

            // Place power-ups
            powerUps = [];
            const numPowerUps = Math.min(Math.floor(level / 3) + 1, 3);

            for (let i = 0; i < numPowerUps; i++) {
                let powerUpPlaced = false;
                while (!powerUpPlaced) {
                    const x = Math.floor(Math.random() * (mazeWidth - 2)) + 1;
                    const y = Math.floor(Math.random() * (mazeHeight - 2)) + 1;

                    if (maze[y][x] === 0) {
                        powerUps.push({
                            x: x * CELL_SIZE + CELL_SIZE / 2,
                            y: y * CELL_SIZE + CELL_SIZE / 2,
                            type: ['dash', 'invisible', 'decoy', 'beacon', 'trap'][Math.floor(Math.random() * 5)]
                        });
                        powerUpPlaced = true;
                    }
                }
            }

            // Reset traps and decoys
            traps = [];
            decoys = [];

            // Reset footsteps
            footsteps = [];
        }

        function generatePath(x, y) {
            // Mark current cell as path
            maze[y][x] = 0;

            // Define possible directions
            const directions = [
                { x: 1, y: 0 },
                { x: -1, y: 0 },
                { x: 0, y: 1 },
                { x: 0, y: -1 }
            ];

            // Shuffle directions
            directions.sort(() => Math.random() - 0.5);

            // Recursively visit neighboring cells
            for (let dir of directions) {
                const newX = x + dir.x * 2;
                const newY = y + dir.y * 2;

                if (newX > 0 && newX < mazeWidth - 1 && newY > 0 && newY < mazeHeight - 1 && maze[newY][newX] === 1) {
                    // Carve a path between current cell and new cell
                    maze[y + dir.y][x + dir.x] = 0;
                    generatePath(newX, newY);
                }
            }
        }

        function update() {
            if (gameState !== 'playing') return;

            const now = Date.now();
            const deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            // Update game state
            updatePlayer(deltaTime);
            updateEnemies(deltaTime);
            updatePowerUps();
            updateTraps();
            updateDecoys();
            updateTime(deltaTime);
            checkCollisions();
            checkWinCondition();

            // Render game
            render();

            // Request next frame
            gameLoop = requestAnimationFrame(update);
        }

        function updatePlayer(deltaTime) {
            // Handle movement
            let speed = player.speed;
            if (keys.sprint && player.sprintEnergy > 0) {
                speed *= 1.5;
                player.sprintEnergy -= 10 * deltaTime;
            } else if (!keys.sprint && player.sprintEnergy < 100) {
                player.sprintEnergy += 5 * deltaTime;
            }

            let newX = player.x;
            let newY = player.y;

            if (keys.up) newY -= speed;
            if (keys.down) newY += speed;
            if (keys.left) newX -= speed;
            if (keys.right) newX += speed;

            // Check for collisions with walls
            if (!checkWallCollision(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }

            // Add footsteps
            if (now - lastFootstepTime > 500) {
                footsteps.push({ x: player.x, y: player.y, opacity: 1 });
                lastFootstepTime = now;
            }

            // Update footsteps
            footsteps.forEach(footstep => {
                footstep.opacity -= 0.01;
            });
            footsteps = footsteps.filter(footstep => footstep.opacity > 0);
        }

        function updateEnemies(deltaTime) {
            enemies.forEach(enemy => {
                if (enemy.isStunned) {
                    enemy.stunnedTimer -= deltaTime;
                    if (enemy.stunnedTimer <= 0) {
                        enemy.isStunned = false;
                    }
                    return;
                }

                // Move towards player
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
                enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
            });
        }

        function checkCollisions() {
            // Check for player-enemy collisions
            enemies.forEach(enemy => {
                const dist = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                if (dist < PLAYER_SIZE / 2 + ENEMY_SIZE / 2 && !player.isInvisible) {
                    loseLife();
                }
            });

            // Check for player-power-up collisions
            powerUps.forEach((powerUp, index) => {
                const dist = Math.sqrt((player.x - powerUp.x) ** 2 + (player.y - powerUp.y) ** 2);
                if (dist < PLAYER_SIZE / 2 + POWER_UP_SIZE / 2) {
                    collectPowerUp(powerUp.type);
                    powerUps.splice(index, 1);
                }
            });

            // Check for player-exit collision
            const distToExit = Math.sqrt((player.x - (exit.x * CELL_SIZE + CELL_SIZE / 2)) ** 2 +
                               (player.y - (exit.y * CELL_SIZE + CELL_SIZE / 2)) ** 2);
            if (distToExit < PLAYER_SIZE / 2 + EXIT_SIZE / 2) {
                nextLevel();
            }
        }

        function loseLife() {
            lives--;
            livesDisplay.textContent = `Lives: ${lives} ‚ù§Ô∏è`;

            if (lives <= 0) {
                gameOverMessage.textContent = "The phantom caught you!";
                finalLevel.textContent = level;
                gameState = 'gameOver';
                gameOver.style.display = 'flex';
            } else {
                // Reset player position
                player.x = CELL_SIZE + CELL_SIZE / 2;
                player.y = CELL_SIZE + CELL_SIZE / 2;
            }
        }

        function collectPowerUp(type) {
            showNotification(`Collected ${type} power-up!`, 2000);
            // Implement power-up effects here
        }

        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw maze
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = themes[settings.theme].wall;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            // Draw exit
            ctx.fillStyle = themes[settings.theme].exit;
            ctx.fillRect(exit.x * CELL_SIZE, exit.y * CELL_SIZE, EXIT_SIZE, EXIT_SIZE);

            // Draw player
            ctx.fillStyle = themes[settings.theme].player;
            ctx.beginPath();
            ctx.arc(player.x, player.y, PLAYER_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw enemies
            ctx.fillStyle = themes[settings.theme].enemy;
            enemies.forEach(enemy => {
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, ENEMY_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = themes[settings.theme].powerUp;
                ctx.beginPath();
                ctx.arc(powerUp.x, powerUp.y, POWER_UP_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Update minimap
            updateMinimap();
        }

        // (Rest of the functions remain the same as in your original code)

        // Initialize the game
        init();
    </script>
</body>
</html>